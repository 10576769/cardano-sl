{-# LANGUAGE DeriveGeneric   #-}
{-# LANGUAGE TemplateHaskell #-}

{-| An implementation of VSS (wrapping over pvss).
    For more details see <https://github.com/input-output-hk/pvss-haskell>.
-}


module Pos.Crypto.SecretSharing
       (
         -- * Keys and related.
         VssPublicKey
       , VssKeyPair
       , toVssPublicKey
       , vssKeyGen
       , deterministicVssKeyGen

         -- * Sharing
       , DhSecret (..)
       , ShareId
       , EncShare
       , Secret
       , SecretProof
       , SecretSharingExtra
       , Share
       , Threshold
       , shareId
       , encShareId
       , decryptShare
       , genSharedSecret
       , getDhSecret
       , getValidShares
       , recoverSecret
       , secretToDhSecret
       , unsafeRecoverSecret
       , verifyEncShare
       , verifySecretProof
       , verifyShare
       ) where

import           Crypto.PVSS         (Commitment, DecryptedShare, DhSecret (..),
                                      EncryptedShare, ExtraGen, KeyPair (..), Point,
                                      Proof, ShareId, Threshold)
import qualified Crypto.PVSS         as Pvss
import           Crypto.Random       (MonadRandom)
import           Data.Binary         (Binary (..), encode)
import           Data.Hashable       (Hashable)
import qualified Data.Hashable       as Hashable
import           Data.List           (genericLength)
import           Data.List.NonEmpty  (NonEmpty)
import           Data.MessagePack    (MessagePack (..))
import           Data.SafeCopy       (SafeCopy (..), base, deriveSafeCopySimple)
import           Data.Text.Buildable (Buildable)
import qualified Data.Text.Buildable as Buildable
import           Formatting          (bprint, (%))
import           Universum

import           Pos.Crypto.Hashing  (hash, shortHashF)
import           Pos.Crypto.Random   (deterministic, runSecureRandom)
import           Pos.Util            (fromMsgpackBinary, getCopyBinary, putCopyBinary,
                                      toMsgpackBinary)

----------------------------------------------------------------------------
-- Orphan instances
----------------------------------------------------------------------------

instance SafeCopy Pvss.PublicKey where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Pvss.PublicKey"

instance MessagePack Pvss.PublicKey where
    toObject = toMsgpackBinary
    fromObject = fromMsgpackBinary "Pvss.PublicKey"

instance SafeCopy Point where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Point"

instance MessagePack Point where
    toObject = toMsgpackBinary
    fromObject = fromMsgpackBinary "Point"

instance SafeCopy Pvss.Secret where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Pvss.Secret"

instance MessagePack Pvss.Secret where
    toObject = toMsgpackBinary
    fromObject = fromMsgpackBinary "Pvss.Secret"

-- TODO: this one should be in pvss-haskell
instance Binary KeyPair

instance SafeCopy KeyPair where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "KeyPair"

-- If this instance is used, something is likely wrong
-- instance MessagePack KeyPair where
--     toObject = toMsgpackBinary
--     fromObject = fromMsgpackBinary "KeyPair"

instance SafeCopy DecryptedShare where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "DecryptedShare"

instance MessagePack DecryptedShare where
    toObject = toMsgpackBinary
    fromObject = fromMsgpackBinary "DecryptedShare"

instance SafeCopy EncryptedShare where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "EncryptedShare"

instance MessagePack EncryptedShare where
    toObject = toMsgpackBinary
    fromObject = fromMsgpackBinary "EncryptedShare"

instance SafeCopy ExtraGen where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "ExtraGen"

instance MessagePack ExtraGen where
    toObject = toMsgpackBinary
    fromObject = fromMsgpackBinary "ExtraGen"

instance SafeCopy Commitment where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Commitment"

instance MessagePack Commitment where
    toObject = toMsgpackBinary
    fromObject = fromMsgpackBinary "Commitment"

instance SafeCopy Proof where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Proof"

instance MessagePack Proof where
    toObject = toMsgpackBinary
    fromObject = fromMsgpackBinary "Proof"

----------------------------------------------------------------------------
-- Keys
----------------------------------------------------------------------------

-- | This key is used as public key in VSS.
newtype VssPublicKey = VssPublicKey
    { getVssPublicKey :: Pvss.PublicKey
    } deriving (Show, Eq, Binary, Generic)

instance Hashable VssPublicKey where
    hashWithSalt s = Hashable.hashWithSalt s . encode

instance MessagePack VssPublicKey

instance Buildable VssPublicKey where
    build = bprint ("vsspub:"%shortHashF) . hash

-- | This key pair is used to decrypt share generated by VSS.
newtype VssKeyPair =
    VssKeyPair KeyPair
    deriving (Show, Eq, Generic, Binary)

instance Buildable VssKeyPair where
    build = bprint ("vsssec:"%shortHashF) . hash

-- | Extract VssPublicKey from VssKeyPair.
toVssPublicKey :: VssKeyPair -> VssPublicKey
toVssPublicKey (VssKeyPair pair) = VssPublicKey $ Pvss.toPublicKey pair

-- | Generate VssKeyPair using Really Secure™ randomness.
vssKeyGen :: MonadIO m => m VssKeyPair
vssKeyGen = VssKeyPair <$> liftIO (runSecureRandom Pvss.keyPairGenerate)

-- | Generate VssKeyPair using given seed.
deterministicVssKeyGen :: ByteString -> VssKeyPair
deterministicVssKeyGen seed =
    VssKeyPair $ deterministic seed Pvss.keyPairGenerate

----------------------------------------------------------------------------
-- Types
----------------------------------------------------------------------------

-- | Secret can be generated by `genSharedSecret` function along with shares.
newtype Secret = Secret
    { getSecret :: Pvss.Secret
    } deriving (Show, Eq, Binary, Generic)

instance MessagePack Secret

instance Buildable Secret where
    build _ = "secret ¯\\_(ツ)_/¯"

-- | Shares can be used to reconstruct Secret.
newtype Share = Share
    { getShare :: DecryptedShare
    } deriving (Show, Eq, Binary, Generic)

instance MessagePack Share

instance Buildable Share where
    build _ = "share ¯\\_(ツ)_/¯"

-- | Returns id of 'Share'.
shareId :: Share -> ShareId
shareId = Pvss.decryptedShareID . getShare

-- | Encrypted share which needs to be decrypted using VssKeyPair first.
newtype EncShare = EncShare
    { getEncShare :: EncryptedShare
    } deriving (Show, Eq, Binary, Generic)

instance MessagePack EncShare

instance Buildable EncShare where
    build _ = "encrypted share ¯\\_(ツ)_/¯"

-- | Returns id of encrypted share.
encShareId :: EncShare -> ShareId
encShareId = Pvss.shareID . getEncShare

-- | This extra data may be used to verify encrypted share.
data SecretSharingExtra =
    SecretSharingExtra !ExtraGen
                       ![Commitment]
    deriving (Show, Eq, Generic)

instance Binary SecretSharingExtra where
instance MessagePack SecretSharingExtra

-- | SecretProof may be used to commit Secret without revealing it.
newtype SecretProof =
    SecretProof Proof
    deriving (Show, Eq, Binary, Generic)

instance MessagePack SecretProof

----------------------------------------------------------------------------
-- Functions
----------------------------------------------------------------------------

-- | Extract ByteString from DhSecret.
getDhSecret :: DhSecret -> ByteString
getDhSecret (DhSecret s) = s

-- | Transform a Secret into a usable random value.
secretToDhSecret :: Secret -> DhSecret
secretToDhSecret = Pvss.secretToDhSecret . getSecret

-- | Decrypt share using secret key. Doesn't verify if an encrypted
-- share is valid, for this you need to use verifyEncShare.
decryptShare
    :: MonadRandom m
    => VssKeyPair -> EncShare -> m Share
decryptShare (VssKeyPair k) (EncShare encShare) =
    Share <$> Pvss.shareDecrypt k encShare

-- | Generate random secret using MonadRandom and share it between
-- given public keys.
genSharedSecret
    :: MonadRandom m
    => Threshold
    -> NonEmpty VssPublicKey
    -> m (SecretSharingExtra, Secret, SecretProof, [EncShare])
genSharedSecret t = fmap convertRes . Pvss.escrow t . map getVssPublicKey . toList
  where
    convertRes (g, s, p, c, es) =
        (SecretSharingExtra g c, Secret s, SecretProof p, map EncShare es)

-- | Recover secret if there are enough correct shares.
recoverSecret :: Threshold -> [(EncShare, VssPublicKey, Share)] -> Maybe Secret
recoverSecret t = recoverSecretDo t . getValidShares t

recoverSecretDo :: Threshold -> [Share] -> Maybe Secret
recoverSecretDo t shares
    | genericLength shares >= t = Just (unsafeRecoverSecret shares)
    | otherwise = Nothing

-- | Recover Secret from shares. Assumes that number of shares is
-- enough to do it. Consider using `getValidShares` first or
-- use `recoverSecret`
unsafeRecoverSecret :: [Share] -> Secret
unsafeRecoverSecret = Secret . Pvss.recover . map getShare

-- | Get #Threshold decrypted shares from given list, or less if there
-- is not enough.
getValidShares :: Threshold -> [(EncShare, VssPublicKey, Share)] -> [Share]
getValidShares t = map Share . Pvss.getValidRecoveryShares t . map convert
  where
    convert (EncShare es, VssPublicKey p, Share s) = (es, p, s)

-- | Verify an encrypted share using SecretSharingExtra.
verifyEncShare :: SecretSharingExtra -> VssPublicKey -> EncShare -> Bool
verifyEncShare (SecretSharingExtra e c) (VssPublicKey pk) (EncShare es) =
    Pvss.verifyEncryptedShare e c (es, pk)

-- | Verify that Share has been decrypted correctly.
verifyShare :: EncShare -> VssPublicKey -> Share -> Bool
verifyShare (EncShare es) (VssPublicKey pk) (Share sh) =
    Pvss.verifyDecryptedShare (es, pk, sh)

-- | Verify that SecretProof corresponds to Secret.
verifySecretProof :: SecretSharingExtra -> Secret -> SecretProof -> Bool
verifySecretProof (SecretSharingExtra e c) (Secret s) (SecretProof p) =
    Pvss.verifySecret e c s p

----------------------------------------------------------------------------
-- SafeCopy instances
----------------------------------------------------------------------------

deriveSafeCopySimple 0 'base ''VssPublicKey
deriveSafeCopySimple 0 'base ''VssKeyPair
deriveSafeCopySimple 0 'base ''Secret
deriveSafeCopySimple 0 'base ''Share
deriveSafeCopySimple 0 'base ''EncShare
deriveSafeCopySimple 0 'base ''SecretSharingExtra
deriveSafeCopySimple 0 'base ''SecretProof
