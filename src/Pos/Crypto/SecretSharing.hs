{-# LANGUAGE DeriveGeneric   #-}
{-# LANGUAGE TemplateHaskell #-}

-- | Dummy implementation of VSS. It doesn't have any logic now.

module Pos.Crypto.SecretSharing
       (
         -- * Keys and related.
         VssPublicKey
       , VssKeyPair
       , toVssPublicKey
       , vssKeyGen
       , deterministicVssKeyGen

         -- * Sharing
       , EncShare
       , Secret
       , SecretProof
       , SecretSharingExtra
       , Share
       , Threshold
       , decryptShare
       , genSharedSecret
       , getValidShares
       , recoverSecret
       , unsafeRecoverSecret
       , verifyEncShare
       , verifySecretProof
       , verifyShare
       ) where

import           Crypto.PVSS         (Commitment, DecryptedShare, EncryptedShare,
                                      ExtraGen, KeyPair (..), Point, Proof, Threshold)
import qualified Crypto.PVSS         as Pvss
import           Crypto.Random       (MonadRandom)
import           Data.Binary         (Binary (..), encode)
import           Data.Hashable       (Hashable (..))
import           Data.List           (genericLength)
import           Data.MessagePack    (MessagePack (..))
import           Data.SafeCopy       (SafeCopy (..), base, deriveSafeCopySimple)
import           Data.Text.Buildable (Buildable)
import qualified Data.Text.Buildable as Buildable
import           Universum

import           Pos.Crypto.Random   (runSecureRandom)
import           Pos.Util            (getCopyBinary, putCopyBinary)

----------------------------------------------------------------------------
-- Keys
----------------------------------------------------------------------------

-- | This key is used as public key in VSS.
newtype VssPublicKey = VssPublicKey
    { getVssPublicKey :: Point
    } deriving (Show, Eq, Binary)

instance Hashable VssPublicKey where
    hashWithSalt s = hashWithSalt s . encode

instance MessagePack VssPublicKey where
    toObject = notImplemented
    fromObject = notImplemented

-- | This key pair is used to decrypt share generated by VSS.
newtype VssKeyPair = VssKeyPair
    { getVssKeyPair :: KeyPair
    } deriving (Show, Eq, Generic)

-- | Extract VssPublicKey from VssKeyPair.
toVssPublicKey :: VssKeyPair -> VssPublicKey
toVssPublicKey (VssKeyPair (KeyPair _ p)) = VssPublicKey p

-- | Generate VssKeyPair using Really Secure™ randomness.
vssKeyGen :: MonadIO m => m VssKeyPair
vssKeyGen = VssKeyPair <$> liftIO (runSecureRandom Pvss.keyPairGenerate)

-- | Generate VssKeyPair using given seed.
deterministicVssKeyGen :: ByteString -> VssKeyPair
deterministicVssKeyGen _ = notImplemented

----------------------------------------------------------------------------
-- Types
----------------------------------------------------------------------------

-- | Secret can be generated by `genSharedSecret` function along with shares.
newtype Secret = Secret
    { getSecret :: Pvss.Secret
    } deriving (Show, Eq, Binary)

instance MessagePack Secret where
    toObject = notImplemented
    fromObject = notImplemented

instance Buildable Secret where
    build _ = "secret ¯\\_(ツ)_/¯"

-- | Shares can be used to reconstruct Secret.
newtype Share = Share
    { getShare :: DecryptedShare
    } deriving (Show, Eq, Binary)

instance MessagePack Share where
    toObject = notImplemented
    fromObject = notImplemented

instance Buildable Share where
    build _ = "share ¯\\_(ツ)_/¯"

-- | Encrypted share which needs to be decrypted using VssKeyPair first.
newtype EncShare = EncShare
    { getEncShare :: EncryptedShare
    } deriving (Show, Eq, Binary)

instance MessagePack EncShare where
    toObject = notImplemented
    fromObject = notImplemented

instance Buildable EncShare where
    build _ = "encrypted share ¯\\_(ツ)_/¯"

-- | This extra data may be used to verify encrypted share.
data SecretSharingExtra =
    SecretSharingExtra !ExtraGen
                       ![Commitment]
    deriving (Show, Eq, Generic)

instance Binary SecretSharingExtra where

instance MessagePack SecretSharingExtra where
    toObject = notImplemented
    fromObject = notImplemented

-- | SecretProof may be used to commit Secret without revealing it.
newtype SecretProof = SecretProof
    { getSecretProof :: Proof
    } deriving (Show, Eq, Binary)

instance MessagePack SecretProof where
    toObject = notImplemented
    fromObject = notImplemented

----------------------------------------------------------------------------
-- Functions
----------------------------------------------------------------------------

-- | Decrypt share using secret key. Doesn't verify if an encrypted
-- share is valid, for this you need to use verifyEncShare.
decryptShare
    :: MonadRandom m
    => VssKeyPair -> EncShare -> m Share
decryptShare (VssKeyPair k) (EncShare encShare) = Share <$> Pvss.shareDecrypt k encShare

-- | Generate random secret using MonadRandom and share it between
-- given public keys.
genSharedSecret
    :: MonadRandom m
    => Threshold
    -> [VssPublicKey]
    -> m (SecretSharingExtra, Secret, SecretProof, [EncShare])
genSharedSecret t = fmap convertRes . Pvss.escrow t . map getVssPublicKey
  where
    convertRes (g, s, p, c, es) =
        (SecretSharingExtra g c, Secret s, SecretProof p, map EncShare es)

-- | Recover secret if there are enough correct shares.
recoverSecret :: Threshold -> [(EncShare, VssPublicKey, Share)] -> Maybe Secret
recoverSecret t = recoverSecretDo t . getValidShares t

recoverSecretDo :: Threshold -> [Share] -> Maybe Secret
recoverSecretDo t shares
    | genericLength shares >= t = Just (unsafeRecoverSecret shares)
    | otherwise = Nothing

-- | Recover Secret from shares. Assumes that number of shares is
-- enough to do it. Consider using `getValidRecoveryShares` first or
-- use `recoverSecret`
unsafeRecoverSecret :: [Share] -> Secret
unsafeRecoverSecret = Secret . Pvss.recover . map getShare

-- | Get #Threshold decrypted shares from given list, or less if there
-- is not enough.
getValidShares :: Threshold -> [(EncShare, VssPublicKey, Share)] -> [Share]
getValidShares t = map Share . Pvss.getValidRecoveryShares t . map convert
  where
    convert (EncShare es, VssPublicKey p, Share s) = (es, p, s)

-- | Verify an encrypted share using SecretSharingExtra.
verifyEncShare :: SecretSharingExtra -> VssPublicKey -> EncShare -> Bool
verifyEncShare (SecretSharingExtra e c) (VssPublicKey pk) (EncShare es) =
    Pvss.verifyEncryptedShare e c (es, pk)

-- | Verify that Share has been decrypted correctly.
verifyShare :: EncShare -> VssPublicKey -> Share -> Bool
verifyShare (EncShare es) (VssPublicKey pk) (Share sh) =
    Pvss.verifyDecryptedShare (es, pk, sh)

-- | Verify that SecretProof corresponds to Secret.
verifySecretProof :: SecretSharingExtra -> Secret -> SecretProof -> Bool
verifySecretProof (SecretSharingExtra e c) (Secret s) (SecretProof p) =
    Pvss.verifySecret e c s p

----------------------------------------------------------------------------
-- SafeCopy instances
----------------------------------------------------------------------------

instance SafeCopy Point where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Point"

instance SafeCopy DecryptedShare where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "DecryptedShare"

instance SafeCopy ExtraGen where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "ExtraGen"

instance SafeCopy Commitment where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Commitment"

instance SafeCopy EncryptedShare where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "EncryptedShare"

instance SafeCopy Pvss.Secret where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Pvss.Secret"

instance SafeCopy Proof where
    putCopy = putCopyBinary
    getCopy = getCopyBinary "Proof"

deriveSafeCopySimple 0 'base ''VssPublicKey
deriveSafeCopySimple 0 'base ''Secret
deriveSafeCopySimple 0 'base ''Share
deriveSafeCopySimple 0 'base ''EncShare
deriveSafeCopySimple 0 'base ''SecretSharingExtra
deriveSafeCopySimple 0 'base ''SecretProof
