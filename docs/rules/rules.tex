% -*- latex -*-

\documentclass{article}

%% packages %%

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{unicode-math}

\usepackage{hyperref}

%% /packages %%

%% Marginal notes %%

\usepackage{xargs}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
\newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
\newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
\newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question

%% /Marginal notes %%

%% macros %%

\newenvironment{record}{\begin{description}[font=\it]}{\end{description}}

\newcommand{\pos}[2]{{#2}_{#1}}
\newcommand{\length}[1]{|#1|}

\newcommand{\idsof}[1]{\mathcal{I}\!_#1}
\newcommand{\id}{\mathsf{id}}
\newcommand{\txs}{\mathcal{T}}
\newcommand{\txids}{\idsof{\txs}}
\newcommand{\blockids}{\idsof{\mathcal{B}}}
\newcommand{\agentids}{\idsof{\mathcal{A}}}
\newcommand{\slotleader}[1]{\mathsf{sl}(#1)}
\newcommand{\recipient}[1]{\mathsf{recipient}(#1)}
\newcommand{\amount}[1]{\mathsf{amount}(#1)}
\newcommand{\transactions}[1]{\mathsf{transactions}(#1)}
\newcommand{\inputs}[1]{\mathsf{inputs}(#1)}
\newcommand{\outputs}[1]{\mathsf{outputs}(#1)}
\newcommand{\intrans}[1]{\mathsf{trans}(#1)}
\newcommand{\inindex}[1]{\mathsf{index}(#1)}
\newcommand{\witnesses}[1]{\mathsf{witnesses}(#1)}
\newcommand{\minimumfee}[1]{\mathsf{minfee}(#1)}

%% /macros %%

\title{Rule-based specification of the blockchain logic}
%\author{}

\begin{document}

\maketitle

\improvement{At the moment, we ignore multi-party communication, but
  we may have to add some rules related to them in the document.}

This document describes the rules underpinning the blockchain data
structure of Cardano's settlement layer. These rules are described
independently of any network or communication mechanism: it is assumed
that some mechanism provides us with, \emph{e.g.}, blocks, and that
our task is to assume that they are accepted or not. Notably, we make
no distinction between rejecting a block and storing it for later use.

A direct consequence of ignoring the communication mechanisms, is that
we do not have to serialise data, hence data is represented in
abstract syntax, with no reference to a binary representation.

As a further simplification, we ignore any unknown data, unparsed
parameters, and versioning issues. This document specifies the system
as it is.\improvement{We may want to add something about protocol
  updates, though.}

\section{Definitions}

\info{General definitions used in all sections. Like the
  slot-to-leader function, the global-time-to-slot function, the
  abstract syntax of transactions and of blocks, \ldots}

\begin{description}
\item[System of identifiers] A set $A$ is said to \emph{have
    identifiers} if there is a set, written $\idsof{A}$ and an
  injective function $\id ∈ A ⟶ \idsof{A}$. In implementations,
  identifiers are typically realised by cryptographic hash functions,
  which are injective for all intent and purposes.

  When an item $a∈A$ such that $\id(a) = h$ is clear from the context,
  we will often identify $a$ and $h$. Similarly, when given an $a∈A$
  and a $h∈\idsof{A}$,

\item[Agent id] We assume a set $\agentids$ of identifiers
  representing the agents interacting on the blockchain. In an
  implementation agent ids would be public cryptographic keys.

\item[Slot] An integer.\improvement{I'm ignoring epochs for the time
    being}

\item[Slot leader] We assume known a function
  $\slotleader{⋅} ∈ ℕ ⟶ \agentids$ mapping each slot to an agent
  id.\improvement{This function is actually also parametrised by a
    valid blockchain. And doesn't look arbitrarily far into the
    future.}\info{For future reference: an epoch is $10k$ slots.}

\item[Current slot] The current slot is a parameter of every
  verification (\emph{i.e.} it doesn't make sense in general to ask
  whether a chain is valid, only that it is valid \emph{at the current
    slot}). In an implementation, the current slot would be computed
  from the clock time. The role of the current slot is to prevent
  attacks where a malicious slot leader at slot $i+1$ would try to
  issue a block without acknowledging the block issued by the slot
  leader at slot $i$.

\item[Transaction] Transactions have a system of identifiers
  $\txids$.

  A transaction consists of\unsure{Consider using record notation
  for inputs and outputs.}
  \begin{record}
  \item[Inputs] A non-empty list of pairs in $\txids ×
    ℕ$.\improvement{Explain that it represents an output identified by
      its index in the transaction output list}

    For an input $in = (tx, ix) ∈ \txids × ℕ$ we write
    \begin{itemize}
    \item $\intrans{in} = tx$
    \item $\inindex{in} = ix$
    \end{itemize}

  \item[Outputs] A non-empty list of pairs in $\agentids ×
    ℕ$.\improvement{This only embodies pay-to-public-key schemes. For
      pay-to-script and such, we will need further
      refinements.}

    For an output $out = (id, q)$, we write
    \begin{itemize}
    \item $\recipient{out} = id$
    \item $\amount{out} = q$
    \end{itemize}

  \item[Witnesses] A non-empty list of agent ids.\improvement{This
      whole section could be improved with a notation for the set of
      lists over a given type} In an implementation these ids would be
    realised by cryptographic signatures.
  \end{record}

  We assume given a function $\minimumfee{⋅} ∈ \txs ⟶ ℕ$,
  called the minimum fee function.\info{It's not clear that the
    minimum fee, as is currently implemented, is indeed a function of
    the (abstract represention of) the transaction. This may create
    mismatches in tests.}

\item[Block] Blocks have a system of identifier $\blockids$. There is
  a distinguished $b_0∈ \blockids$, called the genesis identifier,
  which is not in the image of $\id$.

  A block
  consists of\improvement{I'm ignoring epoch boundary blocks, and the
    genesis block. Genesis block is not really important, but epoch
    boundary blocks may become relevant for this specification}
  \begin{record}
  \item[predecessor] A block identifier
  \item[slot number] The slot at which the block has been issued
  \item[issuer] The identifier of the agent who issued this block. In
    an implementation, this would be realised by a cryptographic
    signature.
  \item[transactions] A list of transactions\improvement{Ignored:
      secret-sharing, updates, delegation. Eventually we need at least
    delegation}
  \end{record}

\item[Chain] A chain is a sequence of blocks $b₁,…,b_n$ such that the
  predecessor of $b₁$ is the genesis block, and for every $i$, the
  predecessor of $b_{i+1}$ is $b_i$.
\end{description}

\section{Adding a block}

\info{In this section we are interested in specifying what it means to
  add a block, given by other means, on top of some existing
  chain. The state is a single chain (aka list). The block must be
  added on top (aka in front) of it.}

A chain\improvement{We can replace ``chain'' by sequence and put the
  predecessor condition in the validity rule. Though this opens a
  question: from the valid extension rules, can I directly define the
  blockchain's forest data structure?} $b₁,…,b_n$ is said to be
\emph{valid} if $b₁,…,b_{n-1}$ is valid, and $b_n$ is a \emph{valid
  extension} of $b₁,…,b_{n-1}$.

A block $b$ is said to be a valid extension of a valid chain
$b_1,…,b_n$ if all of the following hold
\begin{description}
\item[Predecessor] The predecessor of $b$ is $b_n$.
\item[Not future slot] The slot number is no larger than the current
  slot.
\item[Not past slot] the slot number of $b$ is larger than the slot
  number of $b_n$
\item[Issuer] The issuer is the slot leader at the block's slot
  number\improvement{This ignores delegation}.
\item[Transactions] Each transaction in the block's transactions is
  validated according to the following rules.
  \begin{description}
  \item[Stateless]\hfill
    \begin{description}
    \item[Valid outputs] All the outputs of the transaction must have
      amount $a > 0$.
    \item[No double-spending] The list of inputs contains no duplicate.
    \end{description}
  \item[Stateful] Stateful transaction validation rules are
    parametrised by a list of transactions $τ_1,…,τ_m$ which we will
    abridge as $\overline{τ}$.

    Given a chain $b₁,…,b_n$ and $b$, the block being validated, such
    that $\transactions{b}=t₁,…,t_k$. Then, for the purpose of
    stateful validation of the transaction $t_i$,
    $\overline{τ} =
    \transactions{b₁},…,\transactions{b_n},t₁,…,t_{i-1}$.
    \begin{description}
    \item[Unspent inputs] Each input of the transaction $τ$ is
      unspent. That is for each $i ∈ \inputs{τ}$
      \begin{itemize}
      \item $\overline{τ} = \overline{τ₀},\intrans{i}, \overline{τ_1}$
      \item $\outputs{\intrans{i}}=t₁,…t_k$, $\inindex{i} ⩽ k$
      \item for each $t ∈ \overline{τ₁}$, $i ∉ \inputs{t}$.
      \end{itemize}

      In these conditions, we can extend the function $\recipient{⋅}$
      and $\amount{⋅}$ on the $i$ as
      \begin{itemize}
      \item $\recipient{i} = \recipient{\pos{\inindex{i}}{\outputs{\intrans{i}}}}$
      \item $\amount{i} = \amount{\pos{\inindex{i}}{\outputs{\intrans{i}}}}$
      \end{itemize}
      \info{Remark: in all this rule, we use implicitly
        $\overline{τ}$, to cast $\intrans{i}∈\txids$ to an actual
        transaction. }

    \item[Conservation of value] The total amount of inputs must equal
      the total amount of outputs.
      $$
      \minimumfee{τ} + ∑_{i∈\inputs{τ}} \amount{i}⩽ ∑_{o∈\outputs{τ}} \amount{o}
      $$
    \item[Authorised] The list of witnesses has the same length as the
      list of input
      $$
      \length{\witnesses{τ}} = \length{\inputs{τ}}
      $$
      and for each input, the corresponding witness is the agent id of
      the input
      $$
      ∀ 0<k≤\length{\inputs{τ}}. \recipient{\pos{k}{\inputs{τ}}} =
      \pos{k}{\witnesses{τ}}
      $$
    \end{description}
  \end{description}
\end{description}

\section{Instantiating parameters}
\label{sec:params}

\info{The purpose of this section is to give concrete values to some
  of the parameters of the algorithm}

\subsection{Slot leader selection}
\label{sec:slot-lead-select}

A \emph{number generator} is a function $f ∈ ℕ ⟶ S ⟶ ℕ×S$ for some state
$S$, such that for every $n$ and $s$, $(i,s') = f(n)(s) ⟹ 0 ⩽ i <
n$. For security, we would need to assume that $f(n)$ has good
randomness properties, but we can safely ignore this aspect for the
purpose of this document.

A \emph{stake distribution} is a function $d ∈ \agentids ⟶ ℕ$ with
finite support (\emph{i.e.} such that $d(a) = 0$ for all but a finite
choice of $a$)\improvement{Make a terminology-and-notation section and
  define finite support there, both for partial function and for
  number-valued functions}.

In the rest of the section, we assume given a number generator $f$, a
seed $s_0∈S$, and a stake distribution $d$. Let $N$, the \emph{total
  stake}, be $N=∑_{a∈\agentids} d(a)$ (which is defined since $d$ has
finite support).

Let us define the sequences $(s_n)_{n∈ℕ}$ and $(u_n)_{n>0}$ as
\begin{itemize}
\item $s_0$ is as given above
\item $(u_{n+1}, s_{n+1}) = f(N)(s_n)$
\end{itemize}

We can then define the slot leader function as\improvement{This relies
  on a total ordering of $\agentids$. This needs to be
  specified.}\improvement{This assumes a given seed distribution, but
  this is epoch dependent. We need to be able to describe this bit
  better}

$$
\slotleader{n} = \max_{l∈\agentids} \left( ∑_{a<l} d(a)<u_n \right)
$$

\section{Extending the blockchain}

\info{In this section we will specify the rules used by a slot-leader
  to create a new block. The state is a single chain, plus outstanding
  transactions.}

\section{Entering the mempool}

\info{In this section we want to specify how individual transactions
  are added to or rejected from the mempool. Might have to be moved
  before the blockchain-extension rules. The state is a single chain,
  plus outstanding transactions.}

\section{Selecting the longest chain}

\info{This section is concerned with the purpose of (locally) deciding
  which chain is the longest (\emph{e.g.} if I'm a slot leader, which
  chain I'm going to extend) among all possible chains produced by the
  network. The state is a tree of chains rooted in the origin block.}

\end{document}
