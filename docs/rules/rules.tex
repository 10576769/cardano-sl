% -*- latex -*-

\documentclass{article}

%% packages %%

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{unicode-math}

\usepackage{hyperref}

%% /packages %%

%% Marginal notes %%

\usepackage{xargs}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
\newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
\newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
\newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question

%% /Marginal notes %%

%% macros %%

\newenvironment{record}{\begin{description}[font=\it]}{\end{description}}

\newcommand{\lists}[1]{{#1}^*}
\newcommand{\nelists}[1]{{#1}^+}

\newcommand{\pos}[2]{{#2}_{#1}}
\newcommand{\length}[1]{|#1|}
\newcommand{\rem}[2]{\mathrm{rem}_{#1}(#2)}

\newcommand{\idsof}[1]{\mathcal{I}\!_#1}
\newcommand{\id}{\mathsf{id}}
\newcommand{\txs}{\mathcal{T}}
\newcommand{\txids}{\idsof{\txs}}
\newcommand{\blockids}{\idsof{\mathcal{B}}}
\newcommand{\agentids}{\idsof{\mathcal{A}}}
\newcommand{\slotleader}[3]{\mathsf{sl}(#1,#2,#3)}
\newcommand{\recipient}[1]{\mathsf{recipient}(#1)}
\newcommand{\amount}[1]{\mathsf{amount}(#1)}
\newcommand{\transactions}[1]{\mathsf{transactions}(#1)}
\newcommand{\inputs}[1]{\mathsf{inputs}(#1)}
\newcommand{\outputs}[1]{\mathsf{outputs}(#1)}
\newcommand{\intrans}[1]{\mathsf{trans}(#1)}
\newcommand{\inindex}[1]{\mathsf{index}(#1)}
\newcommand{\witnesses}[1]{\mathsf{witnesses}(#1)}
\newcommand{\minimumfee}[1]{\mathsf{minfee}(#1)}
\newcommand{\stakedistributions}{\mathcal{D}}
\newcommand{\seeds}{\mathcal{S}}
\newcommand{\initialdistribution}{d_{\mathsf{init}}}
\newcommand{\initialseed}{s_{\mathsf{init}}}
\newcommand{\epoch}[1]{\mathsf{epoch}(#1)}
\newcommand{\epochslot}[1]{\mathsf{slot}_\mathsf{epoch}(#1)}
\newcommand{\epochseed}[1]{\mathsf{seed}(#1)}
\newcommand{\epochdistribution}[1]{\mathsf{distr}(#1)}

%% /macros %%

\title{Rule-based specification of the blockchain logic}
%\author{}

\begin{document}

\maketitle

\improvement{At the moment, we ignore multi-party communication, but
  we may have to add some rules related to them in the document.}

This document describes the rules underpinning the blockchain data
structure of Cardano's settlement layer. These rules are described
independently of any network or communication mechanism: it is assumed
that some mechanism provides us with, \emph{e.g.}, blocks, and that
our task is to assume that they are accepted or not. Notably, we make
no distinction between rejecting a block and storing it for later use.

A direct consequence of ignoring the communication mechanisms, is that
we do not have to serialise data, hence data is represented in
abstract syntax, with no reference to a binary representation.

As a further simplification, we ignore any unknown data, unparsed
parameters, and versioning issues. This document specifies the system
as it is.\improvement{We may want to add something about protocol
  updates, though.}

\section{Terminology \& notations}
\label{sec:notations}

\begin{description}
\item[Lists] Given a set $A$, we write $\lists{A}$ for the set of
  lists of elements of $A$, and $\nelists{A}$ for the set of non-empty
  lists of elements of $A$. For an element $a∈A$ we write simply $a$
  for the singleton list. For two lists $l,r∈\lists{A}$, we write
  $l,r$ for their concatenation. For a list $l∈\lists{A}$, we write
  $\length{l}$ for its length.\improvement{Don't I need a notation for
    the empty list? Do we only need non-empty lists?}
\item[Support] Let $f$ be a function $f∈X⟶R$ where $R$ is a semiring
  (typically $ℕ$, $ℤ$, $ℚ$, $ℝ$, …), the \emph{support} of $f$ is
  $\{ x∈X | f(x)≠0 \}$. We say that $f$ has finite support, or that
  $f$ is a function with finite support, if the support of $f$ is
  a finite set.

  A notable property of finite-support function, is that they can be
  summed: $∑_{x∈X}f(x)$ is well-defined. Indeed, it suffices to sum
  over the the (finite!) support of $f$, which, as a finite sum, is
  defined.
\item[Remainder] For any $a∈ℤ$ and $b∈ℕ$, let us write $\rem{a}{b}$
  for the unique $0⩽r<b$ such that $a=qb+r$.
\end{description}

\section{Definitions}

\info{General definitions used in all sections. Like the
  slot-to-leader function, the global-time-to-slot function, the
  abstract syntax of transactions and of blocks, \ldots}

\begin{description}
\item[k] This entire specification is parameterised by a natural
  number $k$. It comes from the Ouroboros paper: it is the depth after
  which a block is considered stable.

\item[System of identifiers] A set $A$ is said to \emph{have
    identifiers} if there is a set, written $\idsof{A}$ and an
  injective function $\id ∈ A ⟶ \idsof{A}$. In implementations,
  identifiers are typically realised by cryptographic hash functions,
  which are injective for all intent and purposes.

  When an item $a∈A$ such that $\id(a) = h$ is clear from the context,
  we will often identify $a$ and $h$. Similarly, when given an $a∈A$
  and a $h∈\idsof{A}$,

\item[Agent id] We assume a set $\agentids$ of identifiers
  representing the agents interacting on the blockchain. In an
  implementation agent ids would be public cryptographic keys.

\item[Stake distribution] A \emph{stake distribution} is a function
  $d ∈ \agentids ⟶ ℕ$ with finite support. We write
  $\stakedistributions$ for the set of stake distributions. We assume
  given an \emph{initial stake distribution}
  $\initialdistribution ∈ \stakedistributions$.

\item[Slot] An integer.

\item[Epoch] Let us define $\epoch{n}$ and $\epochslot{n}$, the
  \emph{epoch decomposition} of a slot, as the unique numbers such
  that $n=\epoch{n}.10k+\epochslot{n}$ and $0⩽ \epochslot{n} < 10k$.

\item[Seeds] We assume given a set $\seeds$ of \emph{seeds}, as well
  as an \emph{initial seed} $\initialseed ∈ \seeds$.

\item[Slot leader] We assume known a function
  $\slotleader{⋅}{⋅}{⋅} ∈ \stakedistributions×\seeds×ℕ ⟶ \agentids$,
  which, given a stake distribution and a source of randomness, maps
  each subsequent slot to an agent id.

\item[Current slot] The current slot is a parameter of every
  verification (\emph{i.e.} it doesn't make sense in general to ask
  whether a chain is valid, only that it is valid \emph{at the current
    slot}). In an implementation, the current slot would be computed
  from the clock time. The role of the current slot is to prevent
  attacks where a malicious slot leader at slot $i+1$ would try to
  issue a block without acknowledging the block issued by the slot
  leader at slot $i$.

\item[Transaction] Transactions have a system of identifiers
  $\txids$.

  A transaction consists of\unsure{Consider using record notation
  for inputs and outputs.}
  \begin{record}
  \item[Inputs] A non-empty list of pairs in
    $\nelists{(\txids × ℕ)}$.\improvement{Explain that it represents an
      output identified by its index in the transaction output list}

    For an input $in = (tx, ix) ∈ \txids × ℕ$ we write
    \begin{itemize}
    \item $\intrans{in} = tx$
    \item $\inindex{in} = ix$
    \end{itemize}

  \item[Outputs] A non-empty list of pairs in $\nelists{(\agentids ×
    ℕ)}$.\improvement{This only embodies pay-to-public-key schemes. For
      pay-to-script and such, we will need further
      refinements.}

    For an output $out = (id, q)$, we write
    \begin{itemize}
    \item $\recipient{out} = id$
    \item $\amount{out} = q$
    \end{itemize}

  \item[Witnesses] A non-empty list $w∈\nelists{\agentids}$ of agent
    ids. In an implementation these ids would be realised by
    cryptographic signatures.
  \end{record}

  We assume given a function $\minimumfee{⋅} ∈ \txs ⟶ ℕ$,
  called the minimum fee function.\info{It's not clear that the
    minimum fee, as is currently implemented, is indeed a function of
    the (abstract represention of) the transaction. This may create
    mismatches in tests.}

\item[Block] Blocks have a system of identifier $\blockids$. There is
  a distinguished $b_0∈ \blockids$, called the genesis identifier,
  which is not in the image of $\id$.

  A block
  consists of\improvement{I'm ignoring epoch boundary blocks, and the
    genesis block. Genesis block is not really important, but epoch
    boundary blocks may become relevant for this specification}
  \begin{record}
  \item[predecessor] A block identifier
  \item[slot number] The slot at which the block has been issued
  \item[issuer] The identifier of the agent who issued this block. In
    an implementation, this would be realised by a cryptographic
    signature.
  \item[transactions] A list of transactions\improvement{Ignored:
      secret-sharing, updates, delegation. Eventually we need at least
    delegation}
  \end{record}

\item[Chain] A chain is a sequence of blocks $b₁,…,b_n$ such that the
  predecessor of $b₁$ is the genesis block, and for every $i$, the
  predecessor of $b_{i+1}$ is $b_i$.
\end{description}

\section{Adding a block}
\label{sec:adding-block}

\info{In this section we are interested in specifying what it means to
  add a block, given by other means, on top of some existing
  chain. The state is a single chain (aka list). The block must be
  added on top (aka in front) of it.}

A chain\improvement{We can replace ``chain'' by sequence and put the
  predecessor condition in the validity rule. Though this opens a
  question: from the valid extension rules, can I directly define the
  blockchain's forest data structure?} $b₁,…,b_n$ is said to be
\emph{valid} if $b₁,…,b_{n-1}$ is valid, and $b_n$ is a \emph{valid
  extension} of $b₁,…,b_{n-1}$.

A block $b$ is said to be a valid extension of a valid chain
$b_1,…,b_n$ if all of the following hold
\begin{description}
\item[Predecessor] The predecessor of $b$ is $b_n$.
\item[Not future slot] The slot number is no larger than the current
  slot.
\item[Not past slot] the slot number of $b$ is larger than the slot
  number of $b_n$
\item[Issuer] The issuer of $b$ is the slot leader at the block's slot
  number, that is
  $$
  \slotleader{\epochdistribution{b_1,…,b_n}}{\epochseed{b_1,…,b_n}}{\epochslot{slot}}
  $$
  See Section~\ref{sec:derived-functions} for the definitions of
  $\epochdistribution{⋅}$ and $\epochseed{⋅}$.
  \improvement{This ignores delegation}\improvement{this doesn't read
    too well, improve.}
\item[Transactions] Each transaction in the block's transactions is
  validated according to the following rules.
  \begin{description}
  \item[Stateless]\hfill
    \begin{description}
    \item[Valid outputs] All the outputs of the transaction must have
      amount $a > 0$.
    \item[No double-spending] The list of inputs contains no duplicate.
    \end{description}
  \item[Stateful] Stateful transaction validation rules are
    parametrised by a list of transactions $τ_1,…,τ_m$ which we will
    abridge as $\overline{τ}$.

    Given a chain $b₁,…,b_n$ and $b$, the block being validated, such
    that $\transactions{b}=t₁,…,t_k$. Then, for the purpose of
    stateful validation of the transaction $t_i$,
    $\overline{τ} =
    \transactions{b₁},…,\transactions{b_n},t₁,…,t_{i-1}$.
    \begin{description}
    \item[Unspent inputs] Each input of the transaction $τ$ is
      unspent. That is for each $i ∈ \inputs{τ}$\improvement{This does
      not take into account the utxos in the initial state. It should
      be specified.}
      \begin{itemize}
      \item $\overline{τ} = \overline{τ₀},\intrans{i}, \overline{τ_1}$
      \item $\outputs{\intrans{i}}=t₁,…t_k$, $\inindex{i} ⩽ k$
      \item for each $t ∈ \overline{τ₁}$, $i ∉ \inputs{t}$.
      \end{itemize}

      In these conditions, we can extend the function $\recipient{⋅}$
      and $\amount{⋅}$ on the $i$ as
      \begin{itemize}
      \item $\recipient{i} = \recipient{\pos{\inindex{i}}{\outputs{\intrans{i}}}}$
      \item $\amount{i} = \amount{\pos{\inindex{i}}{\outputs{\intrans{i}}}}$
      \end{itemize}
      \info{Remark: in all this rule, we use implicitly
        $\overline{τ}$, to cast $\intrans{i}∈\txids$ to an actual
        transaction. }

    \item[Conservation of value] The total amount of inputs must equal
      the total amount of outputs.
      $$
      \minimumfee{τ} + ∑_{i∈\inputs{τ}} \amount{i}⩽ ∑_{o∈\outputs{τ}} \amount{o}
      $$
    \item[Authorised] The list of witnesses has the same length as the
      list of input
      $$
      \length{\witnesses{τ}} = \length{\inputs{τ}}
      $$
      and for each input, the corresponding witness is the agent id of
      the input
      $$
      ∀ 0<k⩽\length{\inputs{τ}}. \recipient{\pos{k}{\inputs{τ}}} =
      \pos{k}{\witnesses{τ}}
      $$
    \end{description}
  \end{description}
\end{description}

\section{Derived functions}
\label{sec:derived-functions}

\info{This function described function which are defined on valid
  chains. It is mutually recursive with Section~\ref{sec:adding-block}.}

\begin{description}
\item[Stake distribution] \info{The stake distribution at any given
    point, as well as at the last epoch}
\item[Seed] \info{The shared seed at the last epoch}
\end{description}

\section{Instantiating parameters}
\label{sec:params}

\info{The purpose of this section is to give concrete values to some
  of the parameters of the algorithm}

\subsection{Slot leader}
\label{sec:slot-leader}

A \emph{number generator} is a function $f ∈ ℕ ⟶ S ⟶ ℕ×S$ for some set
$S$, such that for every $n$ and $s$, $(i,s') = f(n)(s) ⟹ 0 ⩽ i <
n$. For security, we would need to assume that $f(n)$ has good
randomness properties, but we can safely ignore this aspect for the
purpose of this document.

In the rest of the section, we assume given a number generator $f$, a
seed $s_0∈S$, and a stake distribution $d$. Let $N$, the \emph{total
  stake}, be $N=∑_{a∈\agentids} d(a)$ (which is defined since $d$ has
finite support).

Let us define the sequences $(s_n)_{n∈ℕ}$ and $(u_n)_{n>0}$ as
\begin{itemize}
\item $s_0$ is as given above
\item $(u_{n+1}, s_{n+1}) = f(N)(s_n)$
\end{itemize}

We can then define the slot leader function as\improvement{This relies
  on a total ordering of $\agentids$. This needs to be
  specified.}\improvement{This assumes a given seed distribution, but
  this is epoch dependent. We need to be able to describe this bit
  better}\improvement{The formula works for $u_n ⩾ 1$ but $u_n$ can be
  $0$, should be fixed (either use a $\min$-based formula, or add $+1$
  somewhere)}

$$
\slotleader{d}{s_0}{n} = \max_{l∈\agentids} \left( ∑_{a<l} d(a)<u_n \right)
$$

\subsection{Number generator}
\label{sec:number-generator}

A \emph{binary number generator} is a function $g ∈ ℕ ⟶ S ⟶ ℕ×S$ for
some set $S$, such that for every $n$ and $s$,
$(i,s') = f(n)(s) ⟹ 0 ⩽ i < 2^{kn}$ for some $k$. A typical example is
to have $k=8$ for a generator which produces a byte at a time.

Our goal is to construct a general number generator $f$ as in
Section~\ref{sec:number-generator}. With the additional requirement
that $f(N)$ must be surjective on its first component, and assuming that $g(N)$ is
surjective on its first component\improvement{I think it's better to just put the surjective
  requirement in the definition of (binary) random generators.}

Let us fix $N∈ℕ$ and $s₀∈S$. And define $B = \min_{n∈ℕ}N < 2^{kn}$,
and $(s_n)_{n∈ℕ}$ and $(u_n)_{n>0}$ as\improvement{I could define
  generators once and for all and these could derive from them. This
  seems to require a dependent product though. We can work around this
  defining a family of generators instead.}
\begin{itemize}
\item $s_0$ is as given above
\item $(u_{n+1}, s_{n+1}) = g(B)(s_n)$
\end{itemize}

Let $n₀ = \min_{n>0} \left(\rem{2^{kB}}{N} ⩽ u_n < 2^{kB}\right)$.

We define
$$
f(N)(s₀) = (\rem{u_{n₀}}{N}, s_{n₀})
$$

Note that, by definition of the remainder,
$\{ p∈ℕ | \rem{2^{kB}}{N} ⩽ u_n < 2^{kB} \}$ has $qN$ elements for
some $q$. From which we can deduce that $f(N)$ is surjective on its
first component (and actually: if the frequency of each $p$ in $u_n$
is the same, then the same property also holds of $f$).

\section{Extending the blockchain}

\info{In this section we will specify the rules used by a slot-leader
  to create a new block. The state is a single chain, plus outstanding
  transactions.}

\section{Entering the mempool}

\info{In this section we want to specify how individual transactions
  are added to or rejected from the mempool. Might have to be moved
  before the blockchain-extension rules. The state is a single chain,
  plus outstanding transactions.}

\section{Selecting the longest chain}

\info{This section is concerned with the purpose of (locally) deciding
  which chain is the longest (\emph{e.g.} if I'm a slot leader, which
  chain I'm going to extend) among all possible chains produced by the
  network. The state is a tree of chains rooted in the origin block.}

\end{document}
