% -*- latex -*-

\documentclass{article}

%% packages %%

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{unicode-math}

\usepackage{hyperref}

%% /packages %%

%% Marginal notes %%

\usepackage{xargs}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
\newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
\newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
\newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question

%% /Marginal notes %%

%% macros %%

\newenvironment{record}{\begin{description}[font=\it]}{\end{description}}

\newcommand{\lists}[1]{{#1}^*}
\newcommand{\nelists}[1]{{#1}^+}
\newcommand{\emptylist}{ε}

\newcommand{\pos}[2]{{#2}_{#1}}
\newcommand{\length}[1]{|#1|}
\newcommand{\rem}[2]{\mathrm{rem}_{#1}(#2)}
\newcommand{\supportsize}[1]{|#1|}

\newcommand{\kronecker}[2]{[#1 = #2]}

\newcommand{\idsof}[1]{\mathcal{I}\!_#1}
\newcommand{\id}{\mathsf{id}}
\newcommand{\txs}{\mathcal{T}}
\newcommand{\txids}{\idsof{\txs}}
\newcommand{\txinit}{\txs_{\!\mathsf{init}}}
\newcommand{\blocks}{\mathcal{B}}
\newcommand{\blockids}{\idsof{\blocks}}
\newcommand{\agentids}{\idsof{\mathcal{A}}}
\newcommand{\richmen}{\mathcal{A}_{\mathsf{bootstrap}}}
\newcommand{\slotleader}[3]{\mathsf{sl}(#1,#2,#3)}
\newcommand{\recipient}[1]{\mathsf{recipient}(#1)}
\newcommand{\amount}[1]{\mathsf{amount}(#1)}
\newcommand{\transactions}[1]{\mathsf{transactions}(#1)}
\newcommand{\inputs}[1]{\mathsf{inputs}(#1)}
\newcommand{\outputs}[1]{\mathsf{outputs}(#1)}
\newcommand{\intrans}[1]{\mathsf{trans}(#1)}
\newcommand{\inindex}[1]{\mathsf{index}(#1)}
\newcommand{\witnesses}[1]{\mathsf{witnesses}(#1)}
\newcommand{\minimumfee}[1]{\mathsf{minfee}(#1)}
\newcommand{\stakedistributions}{\mathcal{D}}
\newcommand{\seeds}{\mathcal{S}}
\newcommand{\initialdistribution}{d_{\mathsf{init}}}
\newcommand{\initialseed}{s_{\mathsf{init}}}
\newcommand{\initialdelegation}{g_{\mathsf{init}}}
\newcommand{\transitivefix}[1]{{#1}^ω}
\newcommand{\delegations}[1]{\mathsf{deleg}(#1)}
\newcommand{\epoch}[1]{\mathsf{epoch}(#1)}
\newcommand{\epochslot}[1]{\mathsf{slot}_\mathsf{epoch}(#1)}
\newcommand{\epochseed}[1]{\mathsf{seed}(#1)}
\newcommand{\epochdistribution}[1]{\mathsf{distr}(#1)}
\newcommand{\currentdistribution}[1]{\mathsf{distr}_0(#1)}
\newcommand{\blocktrees}{\mathcal{G}}
\newcommand{\blockchains}{\mathcal{D}}
\newcommand{\maxchains}[1]{\mathcal{M}(#1)}
\newcommand{\height}[1]{\mathsf{height}(#1)}
\newcommand{\delegator}[1]{\mathsf{delegator}(#1)}
\newcommand{\delegatee}[1]{\mathsf{delegatee}(#1)}
\newcommand{\delegationcertificates}[1]{\mathsf{certificates}_\mathsf{delegation}(#1)}
\newcommand{\selectrichman}[1]{\mathsf{select}_\mathsf{bootstrap}(#1)}
\newcommand{\stakerepartitions}{\mathcal{R}}
\newcommand{\repartition}[1]{\mathsf{repartition}(#1)}
\newcommand{\bootstraprepartition}{r_\mathsf{bootstrap}}
\newcommand{\stakeof}[2]{\mathsf{stake}(#1,#2)}

%% /macros %%

\title{Rule-based specification of the blockchain logic}
\author{Erik de Castro Lopo, Nicholas Clarke \& Arnaud Spiwack}

\begin{document}

\maketitle

\section*{Status}
\label{sec:status}

\begin{description}
\item[Draft 0, Mar 14, 2018 (Arnaud)] Outline
\item[Draft 1, Mar 20, 2018 (Arnaud)] First version of the block
  validation rules
\item[Draft 2, Mar 28, 2018 (Arnaud)] Slot leader selection rules
\item[Draft 3, Apr 9, 2018 (Nicholas)] Review by Nicholas Clarke
\item[Draft 4, Apr 13, 2018 (Arnaud)] Partial specification of stake
  delegation and longest chain selection
\item[Draft 5, Apr 17, 2018 (Arnaud)] Specification of delegation
\end{description}

\section{Introduction}
\label{sec:introduction}

\improvement{At the moment, we ignore multi-party communication, but
  we may have to add some rules related to them in the document.}

This document describes the rules underpinning the blockchain data
structure of Cardano's settlement layer. These rules are described
independently of any network or communication mechanism: it is assumed
that some mechanism provides us with, \emph{e.g.}, blocks, and that
our task is to assume that they are accepted or not. Notably, we make
no distinction between rejecting a block and storing it for later use.

A direct consequence of ignoring the communication mechanisms, is that
we do not have to serialise data, hence data is represented in
abstract syntax, with no reference to a binary representation.

As a further simplification, we ignore any unknown data, unparsed
parameters, and versioning issues. This document specifies the system
as it is.\improvement{We may want to add something about protocol
  updates, though.}

\section{Terminology \& notations}
\label{sec:notations}

\begin{description}
\item[Lists] Given a set $A$, we write $\lists{A}$ for the set of lists of
  elements of $A$, and $\nelists{A}$ for the set of non-empty lists of elements
  of $A$. For an element $a∈A$ we write simply $a$ for the singleton list. For
  two lists $l,r∈\lists{A}$, we write $l,r$ for their concatenation. We write
  $\emptylist$ for the empty list.For a list $l∈\lists{A}$, we write
  $\length{l}$ for its length. We write $\pos{i}{l}$ for the $i$-th element of
  the list (the head of the list is $\pos{1}{l}$). We sometimes abuse notation
  and write $x∈l$ for $l = l',x,l''$.

\item[Support] Let $f$ be a function $f∈X⟶R$ where $R$ is a semiring
  (typically $ℕ$, $ℤ$, $ℚ$, $ℝ$, …), the \emph{support} of $f$ is
  $\{ x∈X | f(x)≠0 \}$. We say that $f$ has finite support, or that
  $f$ is a function with finite support, if the support of $f$ is
  a finite set.

  A notable property of finite-support function, is that they can be
  summed: $∑_{x∈X}f(x)$ is well-defined. Indeed, it suffices to sum
  over the the (finite!) support of $f$, which, as a finite sum, is
  defined.

  Finite support function are typically implemented as finite maps (as
  in Haskell's \verb+Data.Map+ module). Where we then interpret absent
  bindings to map to $0$. There are subtleties if we want to test
  equality as natively, such data structure distinguishes bindings to
  $0$ and absence of bindings. One way to solve this is to remove any
  binding to $0$ from the map.

\item[Remainder] For any $a∈ℤ$ and $b∈ℕ$, let us write $\rem{a}{b}$
  for the unique $0⩽r<b$ such that $a=qb+r$.
\end{description}

\section{Definitions}
\label{sec:definitions}

\info{General definitions used in all sections. Like the
  slot-to-leader function, the global-time-to-slot function, the
  abstract syntax of transactions and of blocks, \ldots}

\begin{description}
\item[System of identifiers] A set $A$ is said to \emph{have
    identifiers} if there is a set, written $\idsof{A}$ and an
  injective function $\id ∈ A ⟶ \idsof{A}$. In implementations,
  identifiers are typically realised by cryptographic hash functions,
  which are injective for all intent and purposes.

  When an item $a∈A$ such that $\id(a) = h$ is clear from the context,
  we will often identify $a$ and $h$.

\item[Agent id] We assume a set $\agentids$ of identifiers
  representing the agents interacting on the blockchain. In an
  implementation agent ids would be public cryptographic keys.

\item[Stake distribution] A \emph{stake distribution} is a function
  $d ∈ \agentids ⟶ ℕ$ with finite support. We write
  $\stakedistributions$ for the set of stake distributions.

\item[Slot] An integer.

\item[Seeds] We assume a set $\seeds$ of \emph{seeds}.

\item[Stake repartition] A stake repartition is a function
  $r ∈ \stakerepartitions ⊆ \agentids ⟶ \mathbb{Q}$ with finite
  support, and such that $r(a) ⩾ 0$ for all $a$. And such that
  $∑_{a∈\agentids} r(a) = 1$.

  Repartition are used as part of transaction output to allocate stake
  to parties which are not necessarily the recipient of the
  output. Agent $a$ receive stake in proportion $r(a)$ (with
  subtleties due to rounding, see
  Section~\ref{sec:derived-functions}).

\item[Transaction] Transactions have a system of identifiers
  $\txids$.

  A transaction $t∈\txs$ consists of\unsure{Consider using record notation
  for inputs and outputs.}
  \begin{record}
  \item[Inputs] A non-empty list of pairs in
    $\nelists{(\txids × ℕ)}$.\improvement{Explain that it represents an
      output identified by its index in the transaction output list}

    For an input $in = (tx, ix) ∈ \txids × ℕ$ we write
    \begin{itemize}
    \item $\intrans{in} = tx$
    \item $\inindex{in} = ix$
    \end{itemize}

  \item[Outputs] A non-empty list of triples in
    $\nelists{(\agentids × ℕ × \stakerepartitions)}$.\improvement{This
      only embodies pay-to-public-key schemes. For pay-to-script and
      such, we will need further refinements.}\info{As remarked by
      Manuel Chakravarty and Erik de Castro Lopo, the choice currently
      made in Cardano, that outputs be necessary non-empty, is
      dubious. There is no particular reason for it to be: empty
      output just means that the transaction is pure fees. And Bruno
      Woltzenlogel Paleo's utxo Chimeric Ledger model allows empty
      outputs, because of the belief that it is essential for coloured
      coins.}

    For an output $out = (id, q, r)$, we write
    \begin{itemize}
    \item $\recipient{out} = id$
    \item $\amount{out} = q$
    \item $\repartition{out} = r$
    \end{itemize}

  \item[Witnesses] A non-empty list $w∈\nelists{\agentids}$ of agent
    ids. In an implementation these ids would be realised by
    cryptographic signatures.
  \end{record}

\item[Delegation graph] A delegation graph is a function $g ∈
  \agentids ⟶ \agentids$. The initial delegation graph is defined as
  the identitity function $\initialdelegation(a) = a$.

  Given a delegation graph $g$, we write $\transitivefix{g}$ for the
  partial function defined as
  $$
  \transitivefix{g}(a)=a' \iff ∃n. g^n(a) = a'∧ g(a') = a'
  $$

\item[Block] Blocks have a system of identifier $\blockids$. There is
  a distinguished $b_0∈ \blockids$, called the genesis identifier,
  which is not in the image of $\id$.

  A block $b∈\blocks$
  consists of\improvement{I'm ignoring epoch boundary blocks, and the
    genesis block. Genesis block is not really important, but epoch
    boundary blocks may become relevant for this specification}
  \begin{record}
  \item[predecessor] A block identifier
  \item[slot number] The slot at which the block has been issued
  \item[issuer] The identifier of the agent who issued this block. In
    an implementation, this would be realised by a cryptographic
    signature.
  \item[transactions] A list of transactions\improvement{Ignored:
      secret-sharing, updates.}
  \item[delegation certificates] A list of pairs in
    $\lists{(\agentids×\agentids)}$. For a delegation certificate
    $c = (D,d)∈\agentids×\agentids$, we write
  \begin{itemize}
  \item $\delegator{c}=D$
  \item $\delegatee{c}=d$
  \end{itemize}

  In a concrete implementation, these certificates would be
  cryptographically signed by $D$, to ensure that $D$ is indeed
  authorising $d$ to sign blocks for them.
  \end{record}

\item[Chain] A chain is a sequence of blocks $b₁,…,b_n$ such that the
  predecessor of $b₁$ is the genesis block, and for every $i$, the
  predecessor of $b_{i+1}$ is $b_i$, and the predecessor of $b₁$ is
  $b₀$.

\end{description}

\section{Parameters}
\label{sec:parameters}

\subsection{Validation parameters}
\label{sec:validation-parameters}

This section lists parameters of the validation rules. The concrete
instantiation of most of these parameters in Cardano is specified in
Section~\ref{sec:params}. They are kept abstract in the validation
rules to highlight that the rules can be stated independently of their
concrete value, which simplifies the specification.

\begin{description}
\item[Slot leader] We assume a function
  $\slotleader{⋅}{⋅}{⋅} ∈ \stakedistributions×\seeds×ℕ ⟶ \agentids$,
  which, given a stake distribution and a source of randomness, maps
  each subsequent slot to an agent id. This function is defined in
  Section~\ref{sec:slot-leader}.

\item[Current slot] The current slot is a parameter of the validation
  rules desribed in this document (\emph{i.e.} it doesn't make sense
  in general to ask whether, say, a chain is valid, only that it is
  valid \emph{at the current slot}).

  This parameter is not instantiated in Section~\ref{sec:params}
  because it actually varies. In an implementation, the current slot
  would be a function of the wall-clock time. The role of the current
  slot is to prevent attacks where a malicious slot leader at slot
  $i+1$ would try to issue a block without acknowledging the block
  issued by the slot leader at slot $i$.

\item[Height] We assume a height function
  $\height{⋅} ∈ \lists{\blocks} ⟶ ℕ$\unsure{We may want to restrict
    the parameter of the height function to be chains, or even valid
    chains, but it is probably unnecessary. Which is why I used the
    simpler version for the moment}. It is usually necessary, for the
  sake of good behaviour of the system to assume that
  $\height{b₁,…,b_n} < \height{b₁,…,b_n,b_{n+1}}$, though it is not
  necessary for the specification itself. A typical such function is
  the length of the list, though more refined criterion are usually
  chosen. This function is defined in Section~\ref{sec:height}.
\end{description}

\subsection{Chain parameters}
\label{sec:chain-parameters}

This section lists the parameters of a Cardano block chain. They are
specified in the initial state and can be further modified by updates.

\begin{description}
\item[k] This entire specification is parameterised by a natural
  number $k$. It comes from the Ouroboros paper: it is the depth after
  which a block is considered stable.\info{In Cardano, $k=2160$}

\item[Initial stake distribution] We assume an \emph{initial stake
    distribution} $\initialdistribution ∈ \stakedistributions$.

\item[Initial seed] A distinguished seed $\initialseed ∈ \seeds$.

\item[Minimum fee] We assume a function $\minimumfee{⋅} ∈ \txs ⟶ ℕ$,
  called the minimum fee function.\info{It's not clear that the
    minimum fee, as is currently implemented, is indeed a function of
    the (abstract represention of) the transaction. This may create
    mismatches in tests.}

\item[Initial transactions] We assume a finite subset $\txinit ⊆ \txs$
  of transactions. The intent behind $\txinit$ is that these
  transactions are present ``in the initial state''. They represent
  the initial assets in the system. Their inputs are
  meaningless.\improvement{We may want to compute the initial
    distribution based on $\txinit$.}\improvement{This doesn't model
    the ATRedeem story. Does it matter?}

\item[Epoch] We assume a pair or functions $\epoch{⋅}∈ℕ⟶ℕ$ and
  $\epochslot{⋅}∈ℕ⟶ℕ$, the \emph{epoch decomposition} of a slot, such
  that~--~writing $(\epoch{⋅}, \epochslot{⋅})$ for the function, in
  $ℕ⟶ℕ×ℕ$, which maps a slot $s$ to
  $(\epoch{s}, \epochslot{s})$~--~$(\epoch{⋅}, \epochslot{⋅})$ is a
  strictly increasing function, from the natural ordering of $ℕ$ to
  the lexicographic product of the natural ordering of $ℕ$ with
  itself.\improvement{We may want to additionally impose that the
    inverse image of $e×ℕ$ is downward closed.}\improvement{Layout is
    broken in this paragraph.}\improvement{It will probably be clearer
    to give a name to $(\epoch{⋅}, \epochslot{⋅})$ rather than
    referring to it symbolically. And define the two projection in
    terms of this function, like is done in the rest of the text,
    rather than the other way around.}

  For reference, $\epoch{s}$ and $\epochslot{s}$, are defined, in the
  bootstrap era of Cardano, of as the unique numbers such that
  $s=\epoch{s}\cdot 10k+\epochslot{s}$ and $0⩽ \epochslot{s} <
  10k$.\improvement{Make a standardised remark pagraph formatting for
    this sort of remarks.}

\item[Bootstrap stakeholders] We assume a finite set
  $\richmen ⊆ \agentids$. The bootstrap stakeholders receive all the
  stake during the bootstrap era.\unsure{For the sake of simplicity, I
    assume, for the time being, that the bootstrap stakeholders all
    get the same share of stake of each output. This is not necessary
    in cardano, but it is the case in practice. We can refine later if
    we so wish}

  We assume a stake repartition
  $\bootstraprepartition ∈ \stakerepartitions$ which allocates stake
  to each bootstrap stakeholder in equal proportion. That is\improvement{Define
    cardinal notation for finite-support functions.}
  $$
  \bootstraprepartition(a) = \left\{
    \begin{array}{cl}
      \displaystyle{\frac{1}{\supportsize{r}}}& \mbox{if $a∈\richmen$}\\
      0 & \mbox{otherwise}
    \end{array}\right.
  $$

  We will also assume a function $\selectrichman{⋅} ∈ ℕ ⟶ \richmen$
  which selects one of the bootstrap stakeholder based on the value of an unspent
  output. In a concrete implementation this function needs to have
  good randomness properties.

\end{description}
\section{Adding a block}
\label{sec:adding-block}

\info{In this section we are interested in specifying what it means to
  add a block, given by other means, on top of some existing
  chain. The state is a single chain (aka list). The block must be
  added on top (aka in front) of it.}

A chain \improvement{We can replace ``chain'' by sequence and put the
  predecessor condition in the validity rule. Though this opens a question: from
  the valid extension rules, can I directly define the blockchain's forest data
  structure?} $b₁,…,b_n$ is said to be \emph{valid} if $b₁,…,b_{n-1}$ is valid,
and $b_n$ is a \emph{valid extension} of $b₁,…,b_{n-1}$.

A block $b$ is said to be a valid extension of a valid chain
$b_1,…,b_n$ if all of the following hold
\begin{description}
\item[Predecessor] The predecessor of $b$ is $b_n$ or, if $n=0$, the
  predecessor of $b$ is the genesis identifier $b₀$.
\item[Not future slot] The slot number is no larger than the current
  slot.
\item[Not past slot] the slot number of $b$ is larger than the slot
  number of $b_n$
\item[Issuer] Let $i$ be the issuer of $b$, and let $l$ be the slot
  leader at the slot of $b$:
  $$
  b = \slotleader{\epochdistribution{b_1,…,b_n}}{\epochseed{b_1,…,b_n}}{\epochslot{slot}}
  $$
  See Section~\ref{sec:derived-functions} for the definitions of
  $\epochdistribution{⋅}$ and $\epochseed{⋅}$.
  \improvement{this doesn't read too well, improve.}

  Then, $i$ must be transitively authorised by $b$ in that:
  $$
  i = \transitivefix{\delegations{b₁,…,b_n}}(b)
  $$
  Note that, by definition, there is (at most) a single agent
  autorised by $b$ (it may be $b$ itself, if no delegation certificate
  has been issued). See Section~\ref{sec:derived-functions} for the
  definition of $\delegations{⋅}$.
\item[Transactions] Each transaction in the block's transactions is
  validated according to the following rules.
  \begin{description}
  \item[Stateless]\hfill
    \begin{description}
    \item[Valid outputs] All the outputs of the transaction must have
      amount $a > 0$.
    \item[No double-spending] The list of inputs contains no duplicate.
    \end{description}
  \item[Stateful] Stateful transaction validation rules for a transaction $τ$
    are parametrised by a list of transactions $τ_1,…,τ_m$ which we will abridge
    as $\overline{τ}$.

    Given a chain $b₁,…,b_n$ and $b$, the block being validated, such
    that $\transactions{b}=t₁,…,t_k$. Then, for the purpose of
    stateful validation of the transaction $t_i$, we set
    $\overline{τ} = \transactions{b₁},…,\transactions{b_n},t₁,…,t_{i-1}$.
    \begin{description}
    \item[Unspent inputs] Each input of the transaction $τ$ is
      unspent. That is for each $i ∈ \inputs{τ}$
      \begin{itemize}
      \item $\intrans{i}∈\overline{τ}$ or $\intrans{i} ∈ \txinit$
      \item $\outputs{\intrans{i}}=t₁,…,t_k$, $\inindex{i} ⩽ k$
      \item for each $t ∈ \overline{τ}$, $i ∉ \inputs{t}$.
      \end{itemize}

      In these conditions, we can extend the function $\recipient{⋅}$
      and $\amount{⋅}$, as well as $\repartition{⋅}$, on the $i$ as
      \begin{itemize}
      \item $\recipient{i} = \recipient{\pos{\inindex{i}}{\outputs{\intrans{i}}}}$
      \item $\amount{i} = \amount{\pos{\inindex{i}}{\outputs{\intrans{i}}}}$
      \item $\repartition{i} = \repartition{\pos{\inindex{i}}{\outputs{\intrans{i}}}}$
      \end{itemize}
      \info{Remark: in all this rule, we use implicitly
        $\overline{τ}$, to cast $\intrans{i}∈\txids$ to an actual
        transaction. }

    \item[Conservation of value] The total amount of inputs must equal
      the total amount of outputs.
      $$
      \minimumfee{τ} + ∑_{i∈\inputs{τ}} \amount{i}⩽ ∑_{o∈\outputs{τ}} \amount{o}
      $$
    \item[Authorised] The list of witnesses has the same length as the
      list of inputs
      $$
      \length{\witnesses{τ}} = \length{\inputs{τ}}
      $$
      and for each input, the corresponding witness is the agent id of
      the input
      $$
      ∀ 0<k⩽\length{\inputs{τ}}. \recipient{\pos{k}{\inputs{τ}}} =
      \pos{k}{\witnesses{τ}}
      $$
    \end{description}

    \item[Bootstrap era]\info{These rules are only used during the
      bootstrap era. They are, however, not qualified because in the
      current state of the document, only the bootstrap era is documented.}\hfill
    \begin{description}
    \item[Bootstrap stake delegation] For every output $o∈\outputs{τ}$, the
      stake is delegated in to the bootstrap stakeholders:
      $\repartition{o} = \bootstraprepartition$.\improvement{This is
        slightly imprecise because the bootstrap repartition has two
        representations in Cardano's block chain: it has a name (a
        data constructor), but it can also be represented by a
        explicit map. Only the former is actually permitted}

    \end{description}
  \end{description}

\item[Delegation certificates] Let
  $\overline{c}=\delegationcertificates{b}$ be the list of delegation
  certificates of $b$. Then for any two $c₁,c₂∈\overline{c}$, it must
  hold that $\delegator{c₁}≠\delegator{c₂}$.

  Note that this prevents any agent which has issued a delegation
  certificate to another party to issue any block: they \emph{must} be
  signed by the delegatee (or, transitively, by the agent authorised
  to sign instead of the delegatee). That is, until the agent issues a
  new delegation certificate to itself, which, in effect, revokes any
  previous delegation certificate. See also the definition of
  $\transitivefix{g}$ in Section~\ref{sec:definitions}.

\end{description}

\section{Derived functions}
\label{sec:derived-functions}

\info{This function described function which are defined on valid
  chains. It is mutually recursive with Section~\ref{sec:adding-block}.}

\begin{description}
\item[Stake distribution] Let us define
  $\currentdistribution{τ₁,…,τ_n}$ by induction, for a valid sequence
  of transactions\improvement{Valid sequence of transaction hasn't
    properly been defined, but it's implicit in the definition above,
    it would maybe be worth making more precise.}:
  \begin{itemize}
  \item $\currentdistribution{\emptylist} = \initialdistribution$
  \item Inductively, and writing
    \begin{itemize}
    \item $\kronecker{⋅}{⋅}$ for Kronecker's delta function
      (\emph{i.e.} $\kronecker{i}{j}$ is $1$ if $i=j$ and $0$
      otherwise)
    \item $\stakeof{o}{a} = \repartition{o}(a).\amount{o} ∈ \mathbb{Q}$
    \item For inputs of $τ_{n+1}$, we extend $\stakeof{⋅}{⋅}$ to
      inputs using the validity hypothesis to define $\repartition{i}$ and $\amount{i}$
    \end{itemize}
    We define
\newcommand{\stakerepartitionformula}[4]{∑_{#2∈#3} \left(
            \begin{aligned}
              &⌊\stakeof{#2}{#1}⌋\\
              &\qquad+\\
              &\raisebox{0pt}[0pt][3.5ex]{$\displaystyle{\kronecker{#1}{\selectrichman{\amount{#2}}}\left(\amount{#2} - ∑_{#4∈\agentids}
            ⌊\stakeof{#2}{#4}⌋\right)}$}
            \end{aligned}\right)}
    \begin{align*}
      \makebox[1em][l]{$\currentdistribution{τ₁,…,τ_n, τ_{n+1}}(a) =$}\\
      & \phantom{=} \currentdistribution{τ₁,…τ_n}(a)\\
      & - \stakerepartitionformula{a}{i}{\inputs{τ_{n+1}}}{b}\\
      & + \stakerepartitionformula{a}{o}{\outputs{τ_{n+1}}}{b}
    \end{align*}

    That is, the stake contributed by each unspent output $o$ to $a$
    is the proportion of its value specified by the stake repartition
    of $o$ rounded \emph{down} to the nearest integer. The unallocated
    stake goes to the bootstrap stakeholder specified by the $\selectrichman{⋅}$
    function, applied to the total value of $o$.  \improvement{The
      treatment of remainder as specified here is only valid for the
      bootstrap era.}
  \end{itemize}

  We can then extend $\currentdistribution{⋅}$ on valid chains by defining
  $$
  \currentdistribution{b₁,…,b_n} = \currentdistribution{\transactions{b₁},…,\transactions{b_n}}
  $$
  Finally we define\improvement{There are two imprecise points in this
  definition: first I didn't define $\epoch{⋅}$ on a block, though it
  is easy to. Secondly, this is only defined after the first block,
  so we need to explain what happens for the empty list.}
  $$
  \epochdistribution{b₁,…,b_n} = \currentdistribution{b₁,…,b_{\epoch{b_n}}}
  $$

\item[Seed] \info{The shared seed at the last epoch} Define
  $\epochseed{⋅}$\improvement{Todo}
\item[Delegation graph] Let us define $\delegations{c₁,…,c_n}$, for a
  list of delegation certificates, by indudction:
  \begin{itemize}
  \item $\delegations{\emptylist} = \initialdelegation$
  \item $$
    \delegations{c₁,…,c_n,(D,d)}(a) = \left\{
      \begin{array}{ll}
        d & \mbox{if $a=D$}\\
        \delegations{c₁,…,c_n}(a) & \mbox{otherwise}
      \end{array}\right.
      $$
  \end{itemize}

  We can extend $\delegations{⋅}$ on valid chain by defining
  $$
  \delegations{b₁,…,b_n} = \delegations{\delegationcertificates{b₁},…,\delegationcertificates{b₁}}
  $$

\end{description}

\section{Instantiating parameters}
\label{sec:params}

\info{The purpose of this section is to give concrete values to some
  of the parameters of the algorithm}

\subsection{Height}
\label{sec:height}

The height of a chain is defined as:

$$
\height{b₁,…,b_n} = n
$$

\subsection{Slot leader}
\label{sec:slot-leader}

A \emph{number generator} is a function $f ∈ ℕ ⟶ S ⟶ ℕ×S$ for some set
$S$, such that for every $n$ and $s$, $(i,s') = f(n)(s) ⟹ 0 ⩽ i <
n$. For security, we would need to assume that $f(n)$ has good
randomness properties, but we can safely ignore this aspect for the
purpose of this document.

In the rest of the section, we assume given a number generator $f$, a
seed $s_0∈S$, and a stake distribution $d$. Let $N$, the \emph{total
  stake}, be $N=∑_{a∈\agentids} d(a)$ (which is defined since $d$ has
finite support).

Let us define the sequences $(s_n)_{n∈ℕ}$ and $(u_n)_{n>0}$ as
\begin{itemize}
\item $s_0$ is as given above
\item $(u_{n+1}, s_{n+1}) = f(N)(s_n)$
\end{itemize}

We can then define the slot leader function as\improvement{This relies
  on a total ordering of $\agentids$. This needs to be
  specified.}

$$
\slotleader{d}{s_0}{n} = \min_{l∈\agentids} \left( u_n < ∑_{a⩽l} d(a) \right)
$$

That is, laying the agents in order on a line, and letting each take
$d(a)$ unit of length. We select the agent whose extent on the line
contains $u_n$.

\subsection{Number generator}
\label{sec:number-generator}

A \emph{binary number generator} is a function $g ∈ ℕ ⟶ S ⟶ ℕ×S$ for
some set $S$, such that for every $n$ and $s$,
$(i,s') = f(n)(s) ⟹ 0 ⩽ i < 2^{kn}$ for some $k$. A typical example is
to have $k=8$ for a generator which produces a byte at a time.

Our goal is to construct a general number generator $f$ as in
Section~\ref{sec:number-generator}. With the additional requirement
that $f(N)$ must be surjective on its first component, and assuming that $g(N)$ is
surjective on its first component\improvement{I think it's better to just put the surjective
  requirement in the definition of (binary) random generators.}

Let us fix $N∈ℕ$ and $s₀∈S$. And define $B = \min_{n∈ℕ}N < 2^{kn}$,
and $(s_n)_{n∈ℕ}$ and $(u_n)_{n>0}$ as\improvement{I could define
  generators once and for all and these could derive from them. This
  seems to require a dependent product though. We can work around this
  defining a family of generators instead.}
\begin{itemize}
\item $s_0$ is as given above
\item $(u_{n+1}, s_{n+1}) = g(B)(s_n)$
\end{itemize}

Let $n₀ = \min_{n>0} \left(\rem{2^{kB}}{N} ⩽ u_n < 2^{kB}\right)$.

We define
$$
f(N)(s₀) = (\rem{u_{n₀}}{N}, s_{n₀})
$$

Note that, by definition of the remainder,
$\{ p∈ℕ | \rem{2^{kB}}{N} ⩽ u_n < 2^{kB} \}$ has $qN$ elements for
some $q$. From which we can deduce that $f(N)$ is surjective on its
first component (and actually: if the frequency of each $p$ in $u_n$
is the same, then the same property also holds of $f$).

\section{Extending the blockchain}

\info{In this section we will specify the rules used by a slot-leader
  to create a new block. The state is a single chain, plus outstanding
  transactions.}

\section{Entering the mempool}

\info{In this section we want to specify how individual transactions
  are added to or rejected from the mempool. Might have to be moved
  before the blockchain-extension rules. The state is a single chain,
  plus outstanding transactions.}

\section{Selecting the longest chain}

\info{This section is concerned with the purpose of (locally) deciding
  which chain is the longest (\emph{e.g.} if I'm a slot leader, which
  chain I'm going to extend) among all possible chains produced by the
  network. The state is a tree of chains rooted in the origin block.}

Let us call a blocktree $\mathfrak{T} ∈
\blocktrees$\improvement{Clearly, a better notation for the set of
  blocktrees and the set of blockchains is necessary}{} a finite set of
valid chains, closed under prefix (\emph{i.e.} if
$b₁, …, b_{n+1} ∈ \mathfrak{T}$, then
$b₁, …, b_n ∈ \mathfrak{T}$)\info{This simply means that
  $\mathfrak{T}$ is an arbitrarily branching tree, where the nodes are blocks
  and predecessors point to the parents. And the paths are all valid
  chains.}. Let us define the maximal chains
$\maxchains{\mathfrak{T}} ⊆ \mathfrak{T}$ to be the set of chains
$b₁,…,b_n$ such that for any extension $b₁,…,b_n,b ∉ \mathfrak{T}$.

A blockchain datastructure is a pair $(\mathfrak{C},\mathfrak{T}) ∈
\blockchains ⊆ \lists{\blocks}×\blocktrees$. Such that
\begin{itemize}
\item $\mathfrak{C}$ is a maximal chain of $\mathfrak{T}$:
  $$
  \mathfrak{C} ∈ \maxchains{\mathfrak{T}}
  $$
\item $\mathfrak{C}$ is of maximal height:
  $$
  \height{\mathfrak{C}} = \max_{\mathfrak{D}∈\maxchains{\mathfrak{T}}}
  \left( \height{\mathfrak{D}} \right)
  $$
\end{itemize}

Because a typical height function is the length of the chain,
$\mathfrak{C}$ is often referred to as the longest chain (despite not
necessarily being unique at that height).

Rules to add a block $b$ to the blockchain:

\begin{description}
\item[Predecessor] There must exist $b₁,…,b_n∈ \mathfrak{T}$ such that
  $b_n$ is the predecessor of $b$.
\item[Validity] $b₁,…,b_n,b$ must be a valid chain, let $\mathfrak{T}'
  = \mathfrak{T}∪\{b₁,…,b_n,b\}$
\item[Longest chain] if $\height{b₁,…,b_n,b} > \height{C}$ (note:
  larger \emph{and not equal}) then let $\mathfrak{C}'=b₁,…,b_n,b$
  else let $\mathfrak{C}'=\mathfrak{C}$.
\item[Update] The new blockchain is $(\mathfrak{C}', \mathfrak{T}')$
\end{description}

\appendix

\section{Notes \& further considerations}
\label{sec:notes}

The purpose of this section is to collect information which does not
fit the specification proper, but can illuminate it, or describe how
it can be expanded to meet future requirements.

\subsection{Data validation vs validation rules}
\label{sec:data-validation-vs}

This is a general consideration for specification and implementation
design. The input received by a Cardano node is a piece of serialise
data, that is a string of bits. But validation rules for block are
done on \textsc{ast}s.

There are necessarily some validation done in the conversion from
string of bits to \textsc{ast}: not all string of bits decode to an
\textsc{ast}. This document refers to the rules which reject strings
of bit or make an \textsc{ast} as \emph{data validation}.

The rules to validate data which is already in \textsc{ast} form are
referred to, by contrast, as \emph{logic validation rules}.

Specification documents (this and any future document) are concerned
exclusively with logic validation rules. This raises the
question of what should be data validation rules and what should be
logic validation rules.

A an example, consider stake repartition as defined in
Section~\ref{sec:definitions}: a finite-support function $r∈\agentids
⟶ \mathbb{Q}$ such that $r(a) ⩾ 0$ and $∑_{a∈\agentids} r(a) =
1$. There are two possibilities:
\begin{itemize}
\item Take this as the definition of stake repartition in the
  \textsc{ast}
\item Take $r$ to be an arbitrary finite-support function in the
  \textsc{ast} and verify, as logic validation rules, that the two
  constraints hold
\end{itemize}
In the former case, the properties of $r$ are relegated as data
validation.

Data validation rules are invisible to specification, making
specification shorter, clearer, and easier to reason about. One may
fear that turning logic rules into validation rule may make errors
harder to spot in testing. But the contrary hold, at least in a typed
language like Haskell: validation rules can be enforced by abstract
data types, which can be tested in isolation.

So, having as many data validation rules and as few logic validation
rules as possible makes it easier to write property-based tests, is
more composable, and make specification better. It is therefore
recommanded, for future specification document to make as many rules
as possible into data validation.

\subsection{Lightweight delegation}
\label{sec:lightweight-delegation}

Lightweight delegation is an alternative to heavyweight delegation as
described with the delegation graph and delegation certificates in
this document.

In lightweight delegation, we use a cryptographic subkey signing
scheme to authorise other parties to sign in our stead. The subkey
sharing happens off chain, therefore it is harder to revoke a
certificate (since we don't benefit from the blockchain as a broadcast
channel: if we broadcast a revocation message, it can be received only
partially by the network and new blocks will issued which still accept
the subkey. The subkey is still technically valid. Plus, the economic
insentive probably don't apply, and make it costless to ignore a
revocation).

Lightweight delegation is currently implemented in Cardano, but hasn't
been deployed yet. Therefore it has not been specified in this
document yet, as this document is only concerned with the currently
used features of Cardano.

The main reason to require an off-chain delegation scheme is to be
able to keep one's private key hidden and sign for oneself using
subkeys instead. They can be made single use, at very little cost,
guaranteeing very strong security: even if a private subkey is leaked,
it is useless, and only the private key which is never used directly
is.

From the point of view of the specification, the current view is that
lightweight delegation need not appear at all: we simply assume that
the cryptography allows an agent $a$ to sign with any subkey of its
private key, whenever its private key would be allowed. In this sense,
this document is already ready for lightweight specification. But,
when time comes, we may come to the conclusion that, in fact, we need
some mechanism in the specification, to model lightweight delegation
explicitly.

\end{document}
